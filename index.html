<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Relative Note Sheet Music Sequencer</title>

<!-- MIDI LIBRARY SCRIPTS -->
<script src="https://cdn.jsdelivr.net/npm/midi-writer-js@1.7.1/build/MidiWriter.min.js" defer></script>
<script src="https://unpkg.com/@tonejs/midi" defer></script>
<!-- END MIDI LIBRARY SCRIPTS -->

<style>
    :root {
        --page-bg: #f0f0f0;
        --controls-bg: #ffffff;
        --text-color: #000000;
        --border-color: #cccccc;
        --button-bg: #007bff;
        --button-hover-bg: #0056b3;
        --canvas-bg: #ffffff;
        --line-color: #cccccc;
        --note-color: #000000;
        --playhead-color: #ff0000;
        --selection-color: rgba(0, 123, 255, 0.4);
        --lasso-color: rgba(0, 123, 255, 0.2);
        --lasso-border-color: rgba(0, 123, 255, 0.8);
    }
    body {
        font-family: sans-serif;
        display: flex;
        flex-direction: column;
        align-items: center;
        background-color: var(--page-bg);
        color: var(--text-color);
        margin: 0;
        transition: background-color 0.3s ease, color 0.3s ease;
    }
    h1 {
        margin-top: 20px;
    }
    .control-group {
        margin-block: 10px;
        padding: 10px;
        border: 1px solid var(--border-color);
        border-radius: 8px;
    }
    #controls {
        margin: 20px;
        padding: 0;
        border: 1px solid var(--border-color);
        border-radius: 8px;
        background-color: var(--controls-bg);
        box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        text-align: center;
        transition: background-color 0.3s ease;
    }
    #controls-header {
        padding: 10px;
        font-size: 1.2em;
        font-weight: bold;
        display: flex;
        justify-content: space-between;
        align-items: center;
        user-select: none;
    }
    #controls-content {
        padding: 0 15px 15px 15px;
    }
    #collapseBtn {
        font-family: monospace;
        font-size: 16px;
        padding: 2px 8px;
    }
    #controls label {
        margin-right: 5px;
        margin-left: 10px;
    }
    #controls button {
        padding: 8px 12px;
        font-size: 14px;
        cursor: pointer;
        border-radius: 5px;
        border: 1px solid var(--button-bg);
        background-color: var(--button-bg);
        color: white;
        margin: 2px;
        transition: background-color 0.2s ease;
    }
    #playBtn {
        padding: 12px 20px;
        font-size: 18px;
    }
    #controls button:hover {
        background-color: var(--button-hover-bg);
    }
    #controls button.secondary {
        background-color: #6c757d;
        border-color: #6c757d;
    }
    #controls button.secondary:hover {
        background-color: #5a6268;
    }
    #controls button.toggled {
        background-color: #28a745; /* Green when on */
        border-color: #28a745;
    }
    #controls input[type="range"] {
        width: 120px;
        vertical-align: middle;
    }
    #controls input[type="number"], #controls select, #controls input[type="text"] {
        width: auto;
        padding: 5px;
        vertical-align: middle;
    }
    #edoCustomInput, #rootNoteInput, #totalBeats, #barLinesInput {
        width: 50px;
    }
    #canvas-container {
        width: 80vw;
        overflow-x: auto;
        border: 1px solid #333;
        margin-top: 20px;
    }
    canvas {
        display: block;
        background-color: var(--canvas-bg);
        cursor: default;
        transition: background-color 0.3s ease;
    }
    #modal {
        display: none; position: fixed; z-index: 100; left: 30%; top: 20%;
        border: 1px solid #888; background-color: #fefefe;
        border-radius: 10px; box-shadow: 0 4px 8px 0 rgba(0,0,0,0.2);
    }
    .modal-content {
        padding: 20px;
    }
    #modal-header {
        padding: 10px 20px;
        cursor: move;
        background-color: #007bff;
        color: white;
        border-top-left-radius: 10px;
        border-top-right-radius: 10px;
    }
    .modal-content label { display: block; margin-top: 10px; }
    .modal-content input, .modal-content select { width: 95%; padding: 8px; margin-top: 5px; }
    .close-button { color: #fff; float: right; font-size: 28px; font-weight: bold; cursor: pointer; }
    .info-text { font-size: 12px; color: #555; margin: 0; }
    #bulkAdjustControls {
        border: 1px solid var(--border-color);
        padding: 10px;
        margin-top: 10px;
        border-radius: 5px;
        display: none; /* Hidden by default */
    }
    #bulkAdjustControls label { font-size: 14px; }
    #bulkAdjustControls input { width: 60px; }
</style>
</head>
<body>

<h1>Relative Note Sheet Music Sequencer</h1>

<div id="controls">
    <div id="controls-header">
        <span>Controls</span>
        <button id="collapseBtn">[ - ]</button>
    </div>
    <div id="controls-content">
        <div class="control-group">
            <input type="radio" id="adjustMode" name="mode" value="adjust">
            <label for="adjustMode">Adjust (a)</label>
            <input type="radio" id="insertMode" name="mode" value="insert" checked>
            <label for="insertMode">Insert (s)</label>
            <input type="radio" id="deleteMode" name="mode" value="delete">
            <label for="deleteMode">Delete (d)</label>
             <input type="radio" id="editMode" name="mode" value="edit">
            <label for="editMode">Edit (e)</label>
            <input type="radio" id="movePlayheadMode" name="mode" value="move_playhead">
            <label for="movePlayheadMode">Move Playhead (f)</label>
            <input type="radio" id="insertChordMode" name="mode" value="insert_chord">
            <label for="insertChordMode">Insert Chord (r)</label>
        </div>
         <div class="control-group" id="bulkAdjustControls">
            <h4 style="margin-top:0; margin-bottom: 10px;">Selected Notes Adjustment</h4>
            <label for="bulkHMove">Move Horizontally (beats):</label>
            <input type="number" id="bulkHMove" value="0" step="0.125">
            <label for="bulkVMove">Move Vertically (steps):</label>
            <input type="number" id="bulkVMove" value="0" step="1">
            <button id="applyBulkAdjustBtn">Apply</button>
        </div>
        <div class="control-group">
            <button id="playBtn">Play</button>
            <button id="repeatBtn">Repeat: Off</button>
            <label for="tempo">Tempo:</label>
            <input type="number" id="tempo" value="120" min="40" max="240">
            <label for="volume">Volume:</label>
            <input type="range" id="volume" min="0" max="1" value="0.5" step="0.01">
            <label for="themeSelect">Theme:</label>
            <select id="themeSelect"></select>
            <br><br>
            <label for="initialNoteLength">Initial Note Length:</label>
            <select id="initialNoteLength">
                <option value="4">Whole Note</option>
                <option value="2">Half Note</option>
                <option value="1" selected>Quarter Note</option>
                <option value="0.5">Eighth Note</option>
                <option value="0.25">Sixteenth Note</option>
            </select>
            <label for="vZoom">V-Zoom:</label>
            <input type="range" id="vZoom" min="1" max="5" value="1.5" step="0.1">
            <label for="hZoom">H-Zoom:</label>
            <input type="range" id="hZoom" min="1" max="5" value="1" step="0.1">
            <label for="totalBeats">Beats:</label>
            <input type="number" id="totalBeats" value="16" min="4" step="4">
            <label for="barLinesInput">Bar Lines:</label>
            <input type="number" id="barLinesInput" value="4" min="1" step="1">
            <button id="beatSnapBtn">Beat Snap: Off</button>
        </div>
        <div class="control-group">
            <label for="noteStyleSelect">Display Style:</label>
            <select id="noteStyleSelect">
                <option value="note_value">Note Value</option>
                <option value="circle">Circle</option>
            </select>
            <label for="accidentalModeSelect">Accidentals:</label>
            <select id="accidentalModeSelect">
                <option value="sharps">Sharps</option>
                <option value="demisharps">Demisharps</option>
                <option value="none">None</option>
            </select>
        </div>
        <div class="control-group">
            <button id="displayNoteNameBtn">Note Name: On</button>
            <button id="displayNoteNumberBtn">Note Number: On</button>
            <button id="displayFrequencyBtn">Frequency: On</button>
            <button id="displayCentsBtn">Cents: On</button>
            <button id="displayLengthBtn">Length: On</button>
        </div>
        <div class="control-group">
             <button id="reverbBtn">Reverb: Off</button>
             <label for="reverbAmount">Reverb Amount:</label>
             <input type="range" id="reverbAmount" min="0" max="1" value="0.5" step="0.01">
        </div>
        <div class="control-group">
            <button id="delayBtn">Delay: Off</button>
            <label for="delayTime">Delay Time (s):</label>
            <input type="range" id="delayTime" min="0.01" max="2" value="0.5" step="0.01">
            <label for="delayFeedback">Feedback:</label>
            <input type="range" id="delayFeedback" min="0" max="0.9" value="0.4" step="0.01">
            <label for="delayMix">Mix:</label>
            <input type="range" id="delayMix" min="0" max="1" value="0.5" step="0.01">
        </div>
        <div class="control-group">
            <button id="edo12SnapBtn">12-EDO</button>
            <button id="edo24SnapBtn">24-EDO</button>
            <input type="number" id="edoCustomInput" value="19" min="2">
            <button id="edoCustomSnapBtn">EDO Snap</button>
            <button id="snapOffBtn">Snap Off</button>
        </div>
        <div class="control-group">
            <button id="scaleSnapBtn">Scale Snap: Off</button>
            <label for="scaleSelect">Scale:</label>
            <select id="scaleSelect"></select>
            <label for="rootNoteInput">Root:</label>
            <input type="text" id="rootNoteInput" value="C4">
        </div>
        <div class="control-group">
            <label for="chordType">Chord Type:</label>
            <select id="chordType">
                <option value="Triad">Triad</option>
                <option value="Seventh">Seventh</option>
            </select>
            <label for="arpBeats">Arp Beats:</label>
            <input type="number" id="arpBeats" value="0" step="0.125">
        </div>
        <div class="control-group">
            <button id="loadSoundBtn" class="secondary">Load Sound File</button>
            <label for="baseFreqInput">Base Freq (Hz):</label>
            <input type="number" id="baseFreqInput" value="220" step="0.01">
            <input type="file" id="soundFileInput" accept=".wav,.mp3,.ogg,.flac" style="display: none;">
        </div>
        <div class="control-group">
            <button id="saveFileBtn" class="secondary">Save to File</button>
            <button id="loadFileBtn" class="secondary">Load from File</button>
            <button id="clearAllBtn" class="secondary">Clear All</button>
            <input type="file" id="fileInput" accept=".json" style="display: none;">
        </div>
         <div class="control-group">
            <label for="midiIn">Midi In:</label>
            <select id="midiIn" disabled><option>No MIDI Access</option></select>
            <label for="midiOut">Midi Out:</label>
            <select id="midiOut" disabled><option>No MIDI Access</option></select>
             <br><br>
            <button id="saveMidiBtn" class="secondary">Save to Midi</button>
            <button id="loadMidiBtn" class="secondary">Load from Midi</button>
            <input type="file" id="midiFileInput" accept=".mid,.midi" style="display: none;">
        </div>
        <div class="control-group">
            <p class="info-text"><b>Keyboard Shortcuts:</b> <b>Space</b> = Play/Pause | <b>Shift+Click</b> = Multi-select | <b>w</b> = Rewind | <b>q</b> = Cycle Note Length | <b>e</b> = Edit Note | <b>r</b> = Insert Chord | <b>+/-</b> = Adjust Velocity</p>
        </div>
    </div>
</div>

<div id="canvas-container">
    <canvas id="sequencerCanvas"></canvas>
</div>

<!-- Modal for Note Properties -->
<div id="modal">
    <div id="modal-header">
        <span class="close-button">&times;</span>
        <h2>Note Properties</h2>
    </div>
    <div class="modal-content">
        <p><strong>Note Number:</strong> <span id="modal-note-number"></span></p>
        <label for="modal-horizontal-pos">Horizontal Position (beats):</label>
        <input type="number" id="modal-horizontal-pos" step="0.01">
        
        <label for="modal-note-length-select">Note Length:</label>
        <select id="modal-note-length-select">
            <option value="4">Whole Note</option>
            <option value="2">Half Note</option>
            <option value="1">Quarter Note</option>
            <option value="0.5">Eighth Note</option>
            <option value="0.25">Sixteenth Note</option>
            <option value="custom">Custom</option>
        </select>
        
        <label for="modal-play-length">Play Length (seconds):</label>
        <input type="number" id="modal-play-length" step="0.01">

        <label for="modal-velocity">Velocity (0-127):</label>
        <input type="number" id="modal-velocity" min="0" max="127">
        
        <label for="modal-frequency">Frequency (Hz):</label>
        <input type="number" id="modal-frequency" step="0.01">

        <hr>
        <p style="text-align: center; margin: 5px;"><strong>OR</strong> calculate frequency from interval:</p>

        <label for="modal-base-note">Base Note Number (optional):</label>
        <input type="text" id="modal-base-note" placeholder="e.g., 1 (default is B4)">
        <label for="modal-relative-interval">Relative Interval (ratio or function):</label>
        <input type="text" id="modal-relative-interval" placeholder="e.g., 3/2 or 2^(7/12)">
        <button id="apply-modal-changes" style="margin-top: 15px;">Apply</button>
    </div>
</div>

<script>
    // --- Global DOM Elements & State ---
    const canvas = document.getElementById('sequencerCanvas');
    const ctx = canvas.getContext('2d');
    const canvasContainer = document.getElementById('canvas-container');
    
    let circles = [];
    let circleCounter = 0;
    let isPlaying = false;
    let isRepeatOn = false;
    let playheadPosition = 0;
    let lastTime = 0;
    let tempo = 120;
    let verticalZoom = 1.5;
    let horizontalZoom = 1;
    let currentMode = 'insert';
    let activeEdoSnap = 12;
    let isBeatSnapOn = true;
    let isScaleSnapOn = false;
    let activeScale = 'Major';
    let activeRootNote = 'C4';
    let selectedCircles = [];
    let isDragging = false;
    let dragOffsetX;
    let isLassoing = false;
    let lassoStartPos = { x: 0, y: 0 };
    let lassoEndPos = { x: 0, y: 0 };


    // --- Display State ---
    let noteStyleMode = 'note_value'; // 'note_value' or 'circle'
    let accidentalMode = 'sharps'; // 'sharps', 'demisharps', or 'none'
    let isDisplayingNoteName = true;
    let isDisplayingNoteNumber = true;
    let isDisplayingFrequency = true;
    let isDisplayingCents = true;
    let isDisplayingLength = true;

    // --- Audio & MIDI State ---
    let audioContext;
    let masterGain, dryGain, wetGain, convolver;
    let delay, delayFeedback, delayWetGain, delayDryGain;
    let midiAccess;
    let activeMidiInput = null;
    let activeMidiOutput = null;
    let baseFrequency = 220;
    let roundRobinBuffers = [];
    let roundRobinIndex = 0;

    const roundRobinFileNames = ['A2sound.wav', 'A2sound2.wav', 'A2sound3.wav', 'A2sound4.wav'];

    // --- Image Assets ---
    const sourceImages = {
        demisharp: new Image(), sesquisharp: new Image(), gClef: new Image(), fClef: new Image(),
        whole: new Image(), half: new Image(), quarter: new Image(),
        eighth: new Image(), sixteenth: new Image()
    };
    const coloredImages = {};
    const coloredPlayheadImages = {};
    
    // --- Musical Constants ---
    const PIXELS_PER_BEAT = 50;
    const START_BEAT = 3; 
    const BEAT_SNAP_SUBDIVISION = 4;
    const circleRadius = 10;
    const trebleClefFrequencies = [698.46, 587.33, 493.88, 392.00, 329.63];
    const bassClefFrequencies = [220.00, 174.61, 146.83, 123.47, 98.00];
    const centerLineFrequency = 493.88;
    const noteNames = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
    const PIXELS_PER_SEMITONE = 10;
    const NOTE_DURATIONS_IN_BEATS = [4, 2, 1, 0.5, 0.25];
    const SCALES = {
        'Major': [2, 2, 1, 2, 2, 2, 1],
        'Natural Minor': [2, 1, 2, 2, 1, 2, 2],
        'Harmonic Minor': [2, 1, 2, 2, 1, 3, 1],
        'Melodic Minor': [2, 1, 2, 2, 2, 2, 1],
        'Dorian': [2, 1, 2, 2, 2, 1, 2],
        'Phrygian': [1, 2, 2, 2, 1, 2, 2],
        'Lydian': [2, 2, 2, 1, 2, 2, 1],
        'Mixolydian': [2, 2, 1, 2, 2, 1, 2],
        'Locrian': [1, 2, 2, 1, 2, 2, 2],
        'Pentatonic Major': [2, 2, 3, 2, 3],
        'Pentatonic Minor': [3, 2, 2, 3, 2],
        'Blues': [3, 2, 1, 1, 3, 2],
        'Whole Tone': [2, 2, 2, 2, 2, 2],
        'Chromatic': [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
    };
    let scaleIntervals = {};
    
    const THEMES = {
        'Standard Light': { pageBg: '#f0f0f0', canvas: '#ffffff', textColor: '#000000', lines: '#cccccc', notes: '#000000', playhead: '#ff0000', selection: 'rgba(0, 123, 255, 0.4)', lasso: 'rgba(0, 123, 255, 0.2)', lassoBorder: 'rgba(0, 123, 255, 0.8)', controlsBg: '#ffffff', buttonBg: '#007bff', buttonHover: '#0056b3' },
        'Deep Dark':      { pageBg: '#121212', canvas: '#1e1e1e', textColor: '#e0e0e0', lines: '#444444', notes: '#e0e0e0', playhead: '#ff4d4d', selection: 'rgba(70, 90, 255, 0.5)', lasso: 'rgba(70, 90, 255, 0.2)', lassoBorder: 'rgba(70, 90, 255, 0.8)', controlsBg: '#2a2a2a', buttonBg: '#3e3e3e', buttonHover: '#555555' },
        'Sepia':          { pageBg: '#f4f0e8', canvas: '#faf8f2', textColor: '#5a4d3a', lines: '#d3c0a5', notes: '#5a4d3a', playhead: '#c75c52', selection: 'rgba(139, 105, 60, 0.5)', lasso: 'rgba(139, 105, 60, 0.2)', lassoBorder: 'rgba(139, 105, 60, 0.8)', controlsBg: '#e9e2d7', buttonBg: '#8c7a62', buttonHover: '#6b5c49' },
        'Blueprint':      { pageBg: '#2a3f5a', canvas: '#3a506b', textColor: '#ffffff', lines: '#5a7d9a', notes: '#ffffff', playhead: '#ffcc00', selection: 'rgba(173, 216, 230, 0.5)', lasso: 'rgba(173, 216, 230, 0.2)', lassoBorder: 'rgba(173, 216, 230, 0.8)', controlsBg: '#34495e', buttonBg: '#5a7d9a', buttonHover: '#4e6a85' },
        'Forest':         { pageBg: '#2c3e32', canvas: '#3e5045', textColor: '#e8f5e9', lines: '#6a8a79', notes: '#e8f5e9', playhead: '#f9a825', selection: 'rgba(233, 175, 96, 0.6)', lasso: 'rgba(233, 175, 96, 0.3)', lassoBorder: 'rgba(233, 175, 96, 0.8)', controlsBg: '#374c3d', buttonBg: '#6a8a79', buttonHover: '#5c7a6a' },
        'Rose Quartz':    { pageBg: '#f7f2f6', canvas: '#ffffff', textColor: '#6d435a', lines: '#f2d8e7', notes: '#6d435a', playhead: '#e91e63', selection: 'rgba(255, 182, 193, 0.6)', lasso: 'rgba(255, 182, 193, 0.3)', lassoBorder: 'rgba(255, 182, 193, 0.8)', controlsBg: '#fce4ec', buttonBg: '#c2185b', buttonHover: '#ad1457' },
        'Neon Lights':    { pageBg: '#0d0221', canvas: '#261447', textColor: '#00ff87', lines: '#6a0dad', notes: '#ff00f1', playhead: '#00ff87', selection: 'rgba(108, 92, 231, 0.6)', lasso: 'rgba(108, 92, 231, 0.3)', lassoBorder: 'rgba(108, 92, 231, 0.8)', controlsBg: '#261447', buttonBg: '#ff00f1', buttonHover: '#c700bf' },
        'Noir':           { pageBg: '#1a1a1a', canvas: '#000000', textColor: '#ffffff', lines: '#333333', notes: '#ffffff', playhead: '#e50914', selection: 'rgba(200, 200, 200, 0.5)', lasso: 'rgba(200, 200, 200, 0.2)', lassoBorder: 'rgba(200, 200, 200, 0.8)', controlsBg: '#101010', buttonBg: '#e50914', buttonHover: '#f40612' },
        'Synthwave':      { pageBg: '#241940', canvas: '#1c1433', textColor: '#00d8ff', lines: '#5d4c86', notes: '#ff3f83', playhead: '#00d8ff', selection: 'rgba(255, 232, 105, 0.5)', lasso: 'rgba(255, 232, 105, 0.2)', lassoBorder: 'rgba(255, 232, 105, 0.8)', controlsBg: '#2d2050', buttonBg: '#ff3f83', buttonHover: '#e63876' },
        'Gold':           { pageBg: '#1f1f1f', canvas: '#2b2b2b', textColor: '#ffd700', lines: '#6e5c21', notes: '#ffd700', playhead: '#ffffff', selection: 'rgba(255, 215, 0, 0.4)', lasso: 'rgba(255, 215, 0, 0.2)', lassoBorder: 'rgba(255, 215, 0, 0.8)', controlsBg: '#3c3c3c', buttonBg: '#b8860b', buttonHover: '#daa520' }
    };
    let currentTheme = THEMES['Standard Light'];

    // --- DOM Element References ---
    const playBtn = document.getElementById('playBtn');
    const repeatBtn = document.getElementById('repeatBtn');
    const tempoInput = document.getElementById('tempo');
    const vZoomSlider = document.getElementById('vZoom');
    const hZoomSlider = document.getElementById('hZoom');
    const totalBeatsInput = document.getElementById('totalBeats');
    const barLinesInput = document.getElementById('barLinesInput');
    const volumeSlider = document.getElementById('volume');
    const themeSelect = document.getElementById('themeSelect');
    const edo12SnapBtn = document.getElementById('edo12SnapBtn');
    const edo24SnapBtn = document.getElementById('edo24SnapBtn');
    const edoCustomSnapBtn = document.getElementById('edoCustomSnapBtn');
    const edoCustomInput = document.getElementById('edoCustomInput');
    const snapOffBtn = document.getElementById('snapOffBtn');
    const beatSnapBtn = document.getElementById('beatSnapBtn');
    const scaleSnapBtn = document.getElementById('scaleSnapBtn');
    const scaleSelect = document.getElementById('scaleSelect');
    const rootNoteInput = document.getElementById('rootNoteInput');
    const modeRadios = document.querySelectorAll('input[name="mode"]');
    const initialNoteLengthSelect = document.getElementById('initialNoteLength');
    const saveFileBtn = document.getElementById('saveFileBtn');
    const loadFileBtn = document.getElementById('loadFileBtn');
    const clearAllBtn = document.getElementById('clearAllBtn');
    const fileInput = document.getElementById('fileInput');
    const loadSoundBtn = document.getElementById('loadSoundBtn');
    const soundFileInput = document.getElementById('soundFileInput');
    const baseFreqInput = document.getElementById('baseFreqInput');
    const midiInSelect = document.getElementById('midiIn');
    const midiOutSelect = document.getElementById('midiOut');
    const saveMidiBtn = document.getElementById('saveMidiBtn');
    const loadMidiBtn = document.getElementById('loadMidiBtn');
    const midiFileInput = document.getElementById('midiFileInput');
    const reverbBtn = document.getElementById('reverbBtn');
    const reverbAmountSlider = document.getElementById('reverbAmount');
    const delayBtn = document.getElementById('delayBtn');
    const delayTimeSlider = document.getElementById('delayTime');
    const delayFeedbackSlider = document.getElementById('delayFeedback');
    const delayMixSlider = document.getElementById('delayMix');
    const chordTypeSelect = document.getElementById('chordType');
    const arpBeatsInput = document.getElementById('arpBeats');
    const collapseBtn = document.getElementById('collapseBtn');
    const controlsContent = document.getElementById('controls-content');
    const modal = document.getElementById('modal');
    const modalHeader = document.getElementById('modal-header');
    const closeModalBtn = document.querySelector('.close-button');
    const applyModalBtn = document.getElementById('apply-modal-changes');
    const modalNoteLengthSelect = document.getElementById('modal-note-length-select');
    const modalPlayLengthInput = document.getElementById('modal-play-length');
    const bulkAdjustControls = document.getElementById('bulkAdjustControls');
    const applyBulkAdjustBtn = document.getElementById('applyBulkAdjustBtn');

    const noteStyleSelect = document.getElementById('noteStyleSelect');
    const accidentalModeSelect = document.getElementById('accidentalModeSelect');
    const displayNoteNameBtn = document.getElementById('displayNoteNameBtn');
    const displayNoteNumberBtn = document.getElementById('displayNoteNumberBtn');
    const displayFrequencyBtn = document.getElementById('displayFrequencyBtn');
    const displayCentsBtn = document.getElementById('displayCentsBtn');
    const displayLengthBtn = document.getElementById('displayLengthBtn');

    // --- Core Functions ---
    function init() {
        canvas.height = 1000;
        document.getElementById('insertMode').checked = true;
        
        playheadPosition = START_BEAT * PIXELS_PER_BEAT;

        Object.keys(SCALES).forEach(scaleName => {
            const option = document.createElement('option');
            option.value = scaleName;
            option.textContent = scaleName;
            scaleSelect.appendChild(option);
            scaleIntervals[scaleName] = convertStepsToIntervals(SCALES[scaleName]);
        });

        Object.keys(THEMES).forEach(themeName => {
            const option = document.createElement('option');
            option.value = themeName;
            option.textContent = themeName;
            themeSelect.appendChild(option);
        });
        
        sourceImages.demisharp.src = 'demisharp.png';
        sourceImages.sesquisharp.src = 'sesquisharp.svg';
        sourceImages.gClef.src = 'GClef.png';
        sourceImages.fClef.src = 'FClef.png';
        sourceImages.whole.src = 'whole_note.png';
        sourceImages.half.src = 'half_note.png';
        sourceImages.quarter.src = 'quarter_note.png';
        sourceImages.eighth.src = 'eighth_note.png';
        sourceImages.sixteenth.src = 'sixteenth_note.png';
        
        Object.values(sourceImages).forEach(img => img.onload = () => recolorImages());
        
        tempo = parseInt(tempoInput.value, 10);
        verticalZoom = parseFloat(vZoomSlider.value);
        horizontalZoom = parseFloat(hZoomSlider.value);
        baseFrequency = parseFloat(baseFreqInput.value);
        activeScale = scaleSelect.value;
        activeRootNote = rootNoteInput.value;
        reverbAmountSlider.value = 1.0;
        
        noteStyleSelect.value = noteStyleMode;
        accidentalModeSelect.value = accidentalMode;
        
        updateSnapButtons();
        updateDisplayToggleButtons();
        updateCanvasWidth();
        updateAdjustmentPanelVisibility();

        applyTheme(themeSelect.value);
        setupAudio();
        initMidi();
        addEventListeners();
        
        toggleReverb();
    }

    async function setupAudio() {
        try {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            masterGain = audioContext.createGain();
            dryGain = audioContext.createGain();
            wetGain = audioContext.createGain();
            convolver = audioContext.createConvolver();
            
            setupDelay();

            masterGain.gain.value = volumeSlider.value;
            dryGain.connect(masterGain);
            masterGain.connect(audioContext.destination);

            wetGain.gain.value = reverbAmountSlider.value;
            convolver.buffer = createReverbIR();

            let loadedCount = 0;
            for (const fileName of roundRobinFileNames) {
                try {
                    const response = await fetch(fileName);
                    const arrayBuffer = await response.arrayBuffer();
                    const decodedBuffer = await audioContext.decodeAudioData(arrayBuffer);
                    roundRobinBuffers.push(decodedBuffer);
                    loadedCount++;
                } catch (e) {
                    console.warn(`Could not load round-robin sample: ${fileName}`);
                }
            }
            if (loadedCount === 0) console.warn("No default sound files loaded. Please load a sound file manually.");
        } catch (e) {
            alert("Could not initialize audio. Please use a modern browser.");
        }
    }
    
    function setupDelay() {
        delay = audioContext.createDelay(5.0);
        delayFeedback = audioContext.createGain();
        delayWetGain = audioContext.createGain();
        delayDryGain = audioContext.createGain();

        delay.delayTime.value = delayTimeSlider.value;
        delayFeedback.gain.value = delayFeedbackSlider.value;
        delayWetGain.gain.value = delayMixSlider.value;
        delayDryGain.gain.value = 1.0 - delayMixSlider.value;

        delay.connect(delayFeedback);
        delayFeedback.connect(delay);
        delay.connect(delayWetGain);

        delayWetGain.connect(masterGain);
        delayDryGain.connect(masterGain);
    }
    
    function playSound(frequency, playLength, velocity) {
        if (!audioContext || roundRobinBuffers.length === 0) return;
        if (audioContext.state === 'suspended') audioContext.resume();
        
        const bufferToPlay = roundRobinBuffers[roundRobinIndex];
        roundRobinIndex = (roundRobinIndex + 1) % roundRobinBuffers.length;
        
        const noteGain = audioContext.createGain();
        noteGain.gain.value = (velocity / 127) * (velocity / 127);
        
        noteGain.connect(dryGain);
        noteGain.connect(wetGain);
        noteGain.connect(delayDryGain);
        noteGain.connect(delay);

        const source = audioContext.createBufferSource();
        source.buffer = bufferToPlay;
        source.playbackRate.value = frequency / baseFrequency;
        source.loop = true;
        if (playLength > bufferToPlay.duration) {
            source.loopStart = 0;
            source.loopEnd = bufferToPlay.duration;
        }
        source.connect(noteGain);
        source.start(0);
        source.stop(audioContext.currentTime + playLength);
    }

    function frequencyToY(freq) {
        const staffCenterY = (canvas.height / 2) - 100;
        const semitonesFromCenter = 12 * Math.log2(freq / centerLineFrequency);
        return staffCenterY - (semitonesFromCenter * PIXELS_PER_SEMITONE * verticalZoom);
    }

    function yToFrequency(y) {
        const staffCenterY = (canvas.height / 2) - 100;
        const pixelOffset = staffCenterY - y;
        const semitonesFromCenter = pixelOffset / (PIXELS_PER_SEMITONE * verticalZoom);
        let freq = centerLineFrequency * Math.pow(2, semitonesFromCenter / 12);

        if (activeEdoSnap > 0) {
            const steps = activeEdoSnap * Math.log2(freq / 440.0);
            const roundedSteps = Math.round(steps);
            freq = 440 * Math.pow(2, roundedSteps / activeEdoSnap);
        } else if (isScaleSnapOn) {
            const rootMidi = noteNameToMidi(activeRootNote);
            if (rootMidi !== null) {
                const rawMidi = frequencyToMidiNote(freq);
                const intervals = scaleIntervals[activeScale];
                const scaleNotes = [];
                for (let octave = -5; octave <= 5; octave++) {
                    intervals.forEach(interval => {
                        scaleNotes.push(rootMidi + (octave * 12) + interval);
                    });
                }
                let closestNote = scaleNotes[0];
                let minDistance = Infinity;
                scaleNotes.forEach(note => {
                    const distance = Math.abs(rawMidi - note);
                    if (distance < minDistance) {
                        minDistance = distance;
                        closestNote = note;
                    }
                });
                freq = midiNoteToFrequency(closestNote);
            }
        }
        return freq;
    }
    
    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        canvas.style.backgroundColor = currentTheme.canvas;
        const totalBeats = parseInt(totalBeatsInput.value, 10);
        const barLinesValue = parseInt(barLinesInput.value, 10);

        // Draw beat snap grid
        if (isBeatSnapOn) {
            ctx.strokeStyle = currentTheme.lines + '80';
            ctx.lineWidth = 1;
            const subdivisionWidth = (PIXELS_PER_BEAT / BEAT_SNAP_SUBDIVISION) * horizontalZoom;
            for (let x = START_BEAT * PIXELS_PER_BEAT * horizontalZoom; x < canvas.width; x += subdivisionWidth) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
        }

        // Draw bar lines
        if (barLinesValue > 0) {
            ctx.strokeStyle = currentTheme.notes + '99'; // MODIFIED: Darker, semi-transparent bar lines
            ctx.lineWidth = 1;
            // Loop until the second to last bar, to not draw over the final bar line
            for (let beat = START_BEAT + barLinesValue; beat < START_BEAT + totalBeats; beat += barLinesValue) {
                const x = beat * PIXELS_PER_BEAT * horizontalZoom;
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
        }
        
        // Draw staff lines
        ctx.strokeStyle = currentTheme.lines;
        ctx.lineWidth = 1;
        [...trebleClefFrequencies, ...bassClefFrequencies].forEach(freq => {
            const y = frequencyToY(freq);
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(canvas.width, y);
            ctx.stroke();
        });

        // Draw final bar lines
        ctx.strokeStyle = currentTheme.notes; // MODIFIED: Darker end lines
        const lastBeatX = (START_BEAT + totalBeats) * PIXELS_PER_BEAT * horizontalZoom;
        
        // Draw the last beat line
        ctx.lineWidth = 2; // MODIFIED: Slightly thicker line
        ctx.beginPath();
        ctx.moveTo(lastBeatX, 0);
        ctx.lineTo(lastBeatX, canvas.height);
        ctx.stroke();

        // Draw the thick final line
        ctx.lineWidth = 5; // MODIFIED: Thicker end line
        const endLineX = (START_BEAT + totalBeats + 0.1) * PIXELS_PER_BEAT * horizontalZoom;
        ctx.beginPath();
        ctx.moveTo(endLineX, 0);
        ctx.lineTo(endLineX, canvas.height);
        ctx.stroke();


        // Draw clefs
        const G4_Y = frequencyToY(392.00);
        const F3_Y = frequencyToY(174.61);
        if (coloredImages.gClef) {
            const clefHeight = 12 * PIXELS_PER_SEMITONE * verticalZoom;
            const clefWidth = clefHeight * (sourceImages.gClef.naturalWidth / sourceImages.gClef.naturalHeight);
            ctx.drawImage(coloredImages.gClef, 10, G4_Y - clefHeight/1.5, clefWidth, clefHeight);
        }
        if (coloredImages.fClef) {
            const clefHeight = 4 * PIXELS_PER_SEMITONE * verticalZoom;
            const clefWidth = clefHeight * (sourceImages.fClef.naturalWidth / sourceImages.fClef.naturalHeight);
            ctx.drawImage(coloredImages.fClef, 10, F3_Y - clefHeight/2, clefWidth, clefHeight);
        }

        // --- Draw Notes and Layered Info ---
        circles.forEach(circle => {
            const x = circle.relativeX * PIXELS_PER_BEAT * horizontalZoom;
            const y = frequencyToY(circle.frequency);
            const isSelected = selectedCircles.includes(circle);

            // 1. Draw Selection Highlight
            if (isSelected) {
                ctx.fillStyle = currentTheme.selection;
                ctx.beginPath();
                ctx.arc(x, y, circleRadius + 4, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // 2. Draw Base Note Style (Note Value Image or Circle)
            if (noteStyleMode === 'note_value') {
                const noteImage = getNoteValueImage(circle.playLength, tempo);
                const imageKey = Object.keys(sourceImages).find(key => sourceImages[key] === noteImage);
                if (imageKey) {
                    const imageSet = circle.colliding ? coloredPlayheadImages : coloredImages;
                    const coloredImg = imageSet[imageKey];
                    if(coloredImg){
                        const imgHeight = circleRadius * 4;
                        const imgWidth = imgHeight * (noteImage.naturalWidth / noteImage.naturalHeight);
                        ctx.drawImage(coloredImg, x - imgWidth/2, y - (imgHeight * 4 / 5), imgWidth, imgHeight);
                    }
                }
            } else { // 'circle' style
                ctx.beginPath();
                ctx.arc(x, y, circleRadius, 0, Math.PI * 2);
                ctx.fillStyle = circle.colliding ? currentTheme.playhead : currentTheme.notes;
                ctx.fill();
            }

            // --- 3. Draw Layered Information Overlays ---
            ctx.fillStyle = currentTheme.notes;
            ctx.textAlign = 'center';

            // Draw Note Number
            if (isDisplayingNoteNumber) {
                ctx.font = 'bold 12px sans-serif';
                ctx.textBaseline = 'bottom';
                ctx.fillText(circle.id, x, y - circleRadius - 15);
            }
            
            // Draw Note Name
            if(isDisplayingNoteName) {
                const noteInfo = frequencyToNoteAndCents(circle.frequency);
                ctx.font = '12px sans-serif';
                ctx.textBaseline = 'top';
                ctx.fillText(noteInfo.name, x, y + circleRadius + 5);
            }
            
            // Draw Frequency
            if(isDisplayingFrequency) {
                ctx.font = '10px sans-serif';
                ctx.textBaseline = 'top';
                ctx.fillText(circle.frequency.toFixed(2) + ' Hz', x, y + circleRadius + 20);
            }
            
            // Draw Cents
            if(isDisplayingCents) {
                const noteInfo = frequencyToNoteAndCents(circle.frequency);
                const sign = noteInfo.cents >= 0 ? '+' : '';
                const displayText = `${sign}${noteInfo.cents.toFixed(1)}c`;
                ctx.font = '10px sans-serif';
                ctx.textBaseline = 'top';
                ctx.fillText(displayText, x, y + circleRadius + 32);
            }
            
            // Draw Length Line
            if (isDisplayingLength) {
                const pixelsPerSecond = (tempo / 60) * PIXELS_PER_BEAT * horizontalZoom;
                const lineLengthInPixels = circle.playLength * pixelsPerSecond;
                ctx.strokeStyle = currentTheme.notes;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(x + circleRadius, y);
                ctx.lineTo(x + circleRadius + lineLengthInPixels, y);
                ctx.stroke();
            }

            // 4. Draw Accidentals
            const noteInfo = frequencyToNoteAndCents(circle.frequency);
            if (accidentalMode === 'sharps') {
                if (noteInfo.name.includes('#')) {
                    ctx.font = 'bold 16px sans-serif';
                    ctx.textAlign = 'right';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('#', x - circleRadius - 4, y);
                }
            } else if (accidentalMode === 'demisharps') {
                const cents = getCentsFromNatural(circle.frequency);
                const symbolSize = 16;
                const symbolX = x - circleRadius - symbolSize / 2 - 4;
                const symbolY = y - symbolSize / 2;

                if (cents >= 25 && cents < 75) {
                    if(coloredImages.demisharp) ctx.drawImage(coloredImages.demisharp, symbolX, symbolY, symbolSize, symbolSize);
                } else if (cents >= 75 && cents < 125) {
                    ctx.font = 'bold 18px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('#', x - circleRadius - 8, y);
                } else if (cents >= 125 && cents < 175) {
                    if(coloredImages.sesquisharp) ctx.drawImage(coloredImages.sesquisharp, symbolX, symbolY, symbolSize, symbolSize);
                }
            }
        });

        // --- Draw Lasso ---
        if (isLassoing) {
            ctx.fillStyle = currentTheme.lasso;
            ctx.strokeStyle = currentTheme.lassoBorder;
            ctx.lineWidth = 1;
            const rect = getLassoRect();
            ctx.fillRect(rect.x, rect.y, rect.w, rect.h);
            ctx.strokeRect(rect.x, rect.y, rect.w, rect.h);
        }

        // --- Draw Playhead ---
        ctx.beginPath();
        ctx.moveTo(playheadPosition, 0);
        ctx.lineTo(playheadPosition, canvas.height);
        ctx.strokeStyle = currentTheme.playhead;
        ctx.lineWidth = 2;
        ctx.stroke();
    }


    function gameLoop(timestamp) {
        if (!isPlaying) return;
        const deltaTime = timestamp - (lastTime || timestamp);
        lastTime = timestamp;
        const pixelsPerSecond = (tempo / 60) * PIXELS_PER_BEAT * horizontalZoom;
        const totalBeats = parseInt(totalBeatsInput.value, 10);
        const endPosition = (START_BEAT + totalBeats) * PIXELS_PER_BEAT * horizontalZoom;
        
        playheadPosition += (pixelsPerSecond * deltaTime) / 1000;
        
        if (playheadPosition >= endPosition) {
            if (isRepeatOn) {
                playheadPosition = START_BEAT * PIXELS_PER_BEAT;
                lastTime = performance.now(); // Reset time to avoid jump
            } else {
                isPlaying = false;
                playBtn.textContent = 'Play';
                playheadPosition = START_BEAT * PIXELS_PER_BEAT;
                draw();
                return;
            }
        }

        circles.forEach(circle => {
            const circleX = circle.relativeX * PIXELS_PER_BEAT * horizontalZoom;
            const lastPlayheadPosition = playheadPosition - (pixelsPerSecond * deltaTime) / 1000;
            const hasCollided = lastPlayheadPosition < circleX && playheadPosition >= circleX;

            if (hasCollided) {
                playSound(circle.frequency, circle.playLength, circle.velocity);
                playNoteOnMidiOutput(circle.frequency, circle.playLength, circle.velocity);
                circle.colliding = true;
                setTimeout(() => { circle.colliding = false; draw(); }, 100);
            }
        });

        draw();
        requestAnimationFrame(gameLoop);
    }
    
    // --- Event Listeners Setup ---
    function addEventListeners() {
        playBtn.addEventListener('click', togglePlay);
        repeatBtn.addEventListener('click', toggleRepeat);
        collapseBtn.addEventListener('click', () => {
            const isVisible = controlsContent.style.display !== 'none';
            controlsContent.style.display = isVisible ? 'none' : 'block';
            collapseBtn.textContent = isVisible ? '[ - ]' : '[ + ]';
        });
        tempoInput.addEventListener('change', e => { tempo = parseInt(e.target.value, 10); });
        volumeSlider.addEventListener('input', e => { if(masterGain) masterGain.gain.value = e.target.value; });
        vZoomSlider.addEventListener('input', e => { verticalZoom = parseFloat(e.target.value); draw(); });
        hZoomSlider.addEventListener('input', handleHorizontalZoom);
        totalBeatsInput.addEventListener('change', handleBeatsInputChange);
        barLinesInput.addEventListener('change', draw);
        
        themeSelect.addEventListener('change', e => applyTheme(e.target.value));

        edo12SnapBtn.addEventListener('click', () => handleEdoSnap(12));
        edo24SnapBtn.addEventListener('click', () => handleEdoSnap(24));
        edoCustomSnapBtn.addEventListener('click', () => {
            const val = Math.max(2, parseInt(edoCustomInput.value, 10));
            edoCustomInput.value = val;
            handleEdoSnap(val);
        });
        snapOffBtn.addEventListener('click', () => {
            deactivateAllSnaps();
            updateSnapButtons();
        });
        scaleSnapBtn.addEventListener('click', toggleScaleSnap);
        scaleSelect.addEventListener('change', e => { activeScale = e.target.value; });
        rootNoteInput.addEventListener('change', e => { activeRootNote = e.target.value; });

        beatSnapBtn.addEventListener('click', toggleBeatSnap);
        modeRadios.forEach(radio => radio.addEventListener('change', e => { currentMode = e.target.value; canvas.style.cursor = 'default'; }));
        
        noteStyleSelect.addEventListener('change', (e) => { noteStyleMode = e.target.value; draw(); });
        accidentalModeSelect.addEventListener('change', (e) => { accidentalMode = e.target.value; draw(); });
        displayNoteNameBtn.addEventListener('click', () => { isDisplayingNoteName = !isDisplayingNoteName; updateDisplayToggleButtons(); draw(); });
        displayNoteNumberBtn.addEventListener('click', () => { isDisplayingNoteNumber = !isDisplayingNoteNumber; updateDisplayToggleButtons(); draw(); });
        displayFrequencyBtn.addEventListener('click', () => { isDisplayingFrequency = !isDisplayingFrequency; updateDisplayToggleButtons(); draw(); });
        displayCentsBtn.addEventListener('click', () => { isDisplayingCents = !isDisplayingCents; updateDisplayToggleButtons(); draw(); });
        displayLengthBtn.addEventListener('click', () => { isDisplayingLength = !isDisplayingLength; updateDisplayToggleButtons(); draw(); });

        reverbBtn.addEventListener('click', toggleReverb);
        reverbAmountSlider.addEventListener('input', e => { if (wetGain) wetGain.gain.value = parseFloat(e.target.value); });
        
        delayBtn.addEventListener('click', toggleDelay);
        delayTimeSlider.addEventListener('input', e => { if(delay) delay.delayTime.value = parseFloat(e.target.value); });
        delayFeedbackSlider.addEventListener('input', e => { if(delayFeedback) delayFeedback.gain.value = parseFloat(e.target.value); });
        delayMixSlider.addEventListener('input', e => {
            if(delayWetGain && delayDryGain) {
                delayWetGain.gain.value = parseFloat(e.target.value);
                delayDryGain.gain.value = 1.0 - parseFloat(e.target.value);
            }
        });
        
        document.addEventListener('keydown', e => {
            if (e.target.tagName.toLowerCase() === 'input' || e.target.tagName.toLowerCase() === 'select') return;
            if (e.key === 'a') document.getElementById('adjustMode').click();
            if (e.key === 's') document.getElementById('insertMode').click();
            if (e.key === 'd') document.getElementById('deleteMode').click();
            if (e.key === 'e') document.getElementById('editMode').click();
            if (e.key === 'f') document.getElementById('movePlayheadMode').click();
            if (e.key === 'r') document.getElementById('insertChordMode').click();
            if (e.key === 'w') {
                playheadPosition = START_BEAT * PIXELS_PER_BEAT;
                draw();
            }
            if (e.code === 'Space' || e.key === ' ') { e.preventDefault(); togglePlay(); }

            if (selectedCircles.length > 0) {
                if(e.key === 'q') {
                    selectedCircles.forEach(c => cycleNoteLength(c));
                    draw();
                }
                if(e.key === '=' || e.key === '+') {
                    selectedCircles.forEach(c => c.velocity = Math.min(127, c.velocity + 5));
                    draw();
                }
                if(e.key === '-') {
                     selectedCircles.forEach(c => c.velocity = Math.max(0, c.velocity - 5));
                    draw();
                }
            }
        });

        canvas.addEventListener('mousedown', handleMouseDown);
        canvas.addEventListener('mousemove', handleMouseMove);
        canvas.addEventListener('mouseup', handleMouseUp);
        canvas.addEventListener('mouseout', handleMouseUp);

        saveFileBtn.addEventListener('click', saveProjectToFile);
        loadFileBtn.addEventListener('click', () => fileInput.click());
        fileInput.addEventListener('change', loadProjectFromFile);
        clearAllBtn.addEventListener('click', handleClearAll);

        loadSoundBtn.addEventListener('click', () => soundFileInput.click());
        soundFileInput.addEventListener('change', loadNewSoundFile);
        baseFreqInput.addEventListener('change', e => baseFrequency = parseFloat(e.target.value));

        midiInSelect.addEventListener('change', setMidiInput);
        midiOutSelect.addEventListener('change', setMidiOutput);

        saveMidiBtn.addEventListener('click', () => exportToMidiFile(circles, tempo));
        loadMidiBtn.addEventListener('click', () => midiFileInput.click());
        midiFileInput.addEventListener('change', async (e) => {
            if (e.target.files.length > 0) {
                await importFromMidiFile(e.target.files[0], onMidiImportSuccess);
            }
        });

        closeModalBtn.addEventListener('click', () => modal.style.display = 'none');
        applyModalBtn.addEventListener('click', applyModalChanges);
        applyBulkAdjustBtn.addEventListener('click', applyBulkAdjustment);
        
        modalNoteLengthSelect.addEventListener('change', updatePlayLengthFromModalSelect);
        modalPlayLengthInput.addEventListener('input', updateModalSelectFromPlayLength);
        
        makeModalDraggable(modal, modalHeader);
    }

    // --- File Handling ---
    function saveProjectToFile() {
        const projectData = { tempo, circleCounter, circles };
        const jsonString = JSON.stringify(projectData, null, 2);
        const blob = new Blob([jsonString], { type: 'application/json' });
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = `sequencer-project-${Date.now()}.json`;
        a.click();
        URL.revokeObjectURL(a.href);
    }

    function loadProjectFromFile(event) {
        const file = event.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = e => {
            try {
                const data = JSON.parse(e.target.result);
                if (data.circles && data.tempo) {
                    circles = data.circles.map(c => ({...c, playLength: c.playLength || 0.5, velocity: c.velocity || 100 }));
                    tempo = data.tempo;
                    circleCounter = data.circleCounter || Math.max(0, ...data.circles.map(c => c.id));
                    tempoInput.value = tempo;
                    isPlaying = false; 
                    playBtn.textContent = 'Play'; 
                    playheadPosition = START_BEAT * PIXELS_PER_BEAT;

                    const maxNoteBeat = circles.length > 0 ? Math.max(...circles.map(c => c.relativeX)) : START_BEAT;
                    const requiredBeats = Math.ceil(maxNoteBeat) - START_BEAT;
                    totalBeatsInput.value = Math.max(4, Math.ceil(requiredBeats / 4) * 4);
                    
                    updateCanvasWidth();
                    draw();
                } else alert("Invalid project file format.");
            } catch (error) { alert("Could not parse file."); console.error(error); }
        };
        reader.readAsText(file);
        fileInput.value = '';
    }
    
    async function loadNewSoundFile(event) {
        const file = event.target.files[0];
        if (!file) return;
        if (!audioContext) {
            alert("Audio has not been initialized yet. Please wait a moment.");
            return;
        }
        const reader = new FileReader();
        reader.onload = async (e) => {
             try {
                const decodedBuffer = await audioContext.decodeAudioData(e.target.result);
                roundRobinBuffers = [decodedBuffer];
                alert("Custom sound file loaded. Round-robin is now disabled.");
             } catch(err) {
                 alert("Failed to decode the audio file. Please try a different WAV or MP3 file.");
                 console.error("Error decoding audio data:", err);
             }
        };
        reader.readAsArrayBuffer(file);
        soundFileInput.value = '';
    }
    
    // --- Mouse & UI Handlers ---
    function handleMouseDown(e) {
        const pos = getEventPos(e);

        if (pos.x < START_BEAT * PIXELS_PER_BEAT * horizontalZoom) {
            if (!e.shiftKey) selectedCircles = [];
            updateAdjustmentPanelVisibility();
            draw();
            return;
        }

        const clickedCircle = getCircleAtPos(pos);
        
        if (currentMode === 'insert') {
            if (!clickedCircle) addCircle(pos);
        } else if (currentMode === 'insert_chord') {
             if (!clickedCircle) addChord(pos);
        } else if (currentMode === 'delete') {
            if (clickedCircle) deleteCircle(clickedCircle);
        } else if (currentMode === 'adjust') {
            if (clickedCircle) {
                isDragging = true;
                if (!selectedCircles.includes(clickedCircle)) {
                     if (!e.shiftKey) selectedCircles = [clickedCircle];
                     else selectedCircles.push(clickedCircle);
                }
                dragOffsetX = (clickedCircle.relativeX * PIXELS_PER_BEAT * horizontalZoom) - pos.x;
            } else {
                 isLassoing = true;
                 if (!e.shiftKey) selectedCircles = [];
                 lassoStartPos = pos;
                 lassoEndPos = pos;
            }
        } else if (currentMode === 'edit') {
            if (clickedCircle) openModal(clickedCircle);
        } else if (currentMode === 'move_playhead') {
            playheadPosition = Math.max(START_BEAT * PIXELS_PER_BEAT, pos.x);
        }

        if (currentMode !== 'adjust') {
            if (clickedCircle) {
                if (!e.shiftKey) selectedCircles = [clickedCircle];
                else if (!selectedCircles.includes(clickedCircle)) selectedCircles.push(clickedCircle);
            } else {
                 if (!e.shiftKey) selectedCircles = [];
            }
        }
        
        updateAdjustmentPanelVisibility();
        draw();
    }

    function handleMouseMove(e) {
        const pos = getEventPos(e);
        const circleUnderMouse = getCircleAtPos(pos);

        if (isLassoing) {
            lassoEndPos = pos;
            draw();
            return;
        }

        if (currentMode === 'delete' && circleUnderMouse) canvas.style.cursor = 'crosshair';
        else if (currentMode === 'adjust' && (isDragging || circleUnderMouse)) canvas.style.cursor = 'move';
        else if (currentMode === 'edit' && circleUnderMouse) canvas.style.cursor = 'pointer';
        else if (currentMode === 'move_playhead') canvas.style.cursor = 'e-resize';
        else canvas.style.cursor = 'default';

        if (isDragging && selectedCircles.length > 0) {
            const firstCircle = selectedCircles[0];
            let newFirstCircleX = (pos.x + dragOffsetX) / (PIXELS_PER_BEAT * horizontalZoom);

            if (isBeatSnapOn) {
                newFirstCircleX = Math.round(newFirstCircleX * BEAT_SNAP_SUBDIVISION) / BEAT_SNAP_SUBDIVISION;
            }

            const deltaX = newFirstCircleX - firstCircle.relativeX;
            const deltaY = pos.y - frequencyToY(firstCircle.frequency);
            
            selectedCircles.forEach(circle => {
                const maxBeat = START_BEAT + parseInt(totalBeatsInput.value, 10);
                circle.relativeX = Math.min(maxBeat, Math.max(START_BEAT, circle.relativeX + deltaX));
                
                const newY = frequencyToY(circle.frequency) + deltaY;
                circle.frequency = yToFrequency(newY);
            });
            draw();
        }
    }

    function handleMouseUp(e) { 
        if (isLassoing) {
            isLassoing = false;
            selectCirclesInLasso();
            updateAdjustmentPanelVisibility();
            draw();
        }
        if (isDragging) { 
            isDragging = false; 
        } 
    }
    
    function handleClearAll() {
        if (confirm("Do you really want to clear all the notes?")) {
            circles = [];
            selectedCircles = [];
            circleCounter = 0;
            playheadPosition = START_BEAT * PIXELS_PER_BEAT;
            updateAdjustmentPanelVisibility();
            draw();
        }
    }

    function handleHorizontalZoom(e) {
        horizontalZoom = parseFloat(e.target.value);
        updateCanvasWidth();
        draw();
    }

    function handleBeatsInputChange(e) {
        const newBeats = parseInt(e.target.value, 10);
        if (isNaN(newBeats) || newBeats < 4) {
            e.target.value = 4;
        }
        
        const maxBeat = START_BEAT + newBeats;
        const outOfBoundsNotes = circles.filter(c => c.relativeX > maxBeat);

        if (outOfBoundsNotes.length > 0) {
            if (confirm("This will delete notes outside the new range. Continue?")) {
                circles = circles.filter(c => c.relativeX <= maxBeat);
            } else {
                const maxNoteBeat = circles.length > 0 ? Math.max(...circles.map(c => c.relativeX)) : START_BEAT;
                const requiredBeats = Math.ceil(maxNoteBeat) - START_BEAT;
                e.target.value = Math.max(4, Math.ceil(requiredBeats / 4) * 4);
                return;
            }
        }

        updateCanvasWidth();
        draw();
    }
    
    function updateCanvasWidth() {
        const totalBeats = parseInt(totalBeatsInput.value, 10) || 16;
        const calculatedWidth = (totalBeats + START_BEAT + 2) * PIXELS_PER_BEAT * horizontalZoom; // Add extra for end bar
        canvas.width = Math.max(canvasContainer.clientWidth, calculatedWidth);
    }
    
    function togglePlay() {
        if (!audioContext) { setupAudio(); return; }
        if (audioContext.state === 'suspended') audioContext.resume();
        isPlaying = !isPlaying;
        if (isPlaying) {
            playBtn.textContent = 'Pause';
            const totalBeats = parseInt(totalBeatsInput.value, 10);
            const endPosition = (START_BEAT + totalBeats) * PIXELS_PER_BEAT * horizontalZoom;
            if (playheadPosition >= endPosition) {
                playheadPosition = START_BEAT * PIXELS_PER_BEAT;
            }
            lastTime = performance.now();
            requestAnimationFrame(gameLoop);
        } else {
            playBtn.textContent = 'Play';
        }
    }

    function toggleRepeat() {
        isRepeatOn = !isRepeatOn;
        repeatBtn.textContent = `Repeat: ${isRepeatOn ? 'On' : 'Off'}`;
        repeatBtn.classList.toggle('toggled', isRepeatOn);
    }
    
    function handleEdoSnap(edoValue) {
        if (activeEdoSnap === edoValue) {
            activeEdoSnap = 0;
        } else {
            deactivateAllSnaps();
            activeEdoSnap = edoValue;
        }
        updateSnapButtons();
    }

    function toggleScaleSnap() {
        if (isScaleSnapOn) {
            isScaleSnapOn = false;
        } else {
            deactivateAllSnaps();
            isScaleSnapOn = true;
        }
        updateSnapButtons();
    }
    
    function toggleBeatSnap() {
        isBeatSnapOn = !isBeatSnapOn;
        updateSnapButtons();
        draw();
    }
    
    function deactivateAllSnaps() {
        activeEdoSnap = 0;
        isScaleSnapOn = false;
    }
    
    function updateAdjustmentPanelVisibility() {
        bulkAdjustControls.style.display = selectedCircles.length > 0 ? 'block' : 'none';
    }

    function updateDisplayToggleButtons() {
        displayNoteNameBtn.textContent = `Note Name: ${isDisplayingNoteName ? 'On' : 'Off'}`;
        displayNoteNameBtn.classList.toggle('toggled', isDisplayingNoteName);
        
        displayNoteNumberBtn.textContent = `Note Number: ${isDisplayingNoteNumber ? 'On' : 'Off'}`;
        displayNoteNumberBtn.classList.toggle('toggled', isDisplayingNoteNumber);
        
        displayFrequencyBtn.textContent = `Frequency: ${isDisplayingFrequency ? 'On' : 'Off'}`;
        displayFrequencyBtn.classList.toggle('toggled', isDisplayingFrequency);
        
        displayCentsBtn.textContent = `Cents: ${isDisplayingCents ? 'On' : 'Off'}`;
        displayCentsBtn.classList.toggle('toggled', isDisplayingCents);

        displayLengthBtn.textContent = `Length: ${isDisplayingLength ? 'On' : 'Off'}`;
        displayLengthBtn.classList.toggle('toggled', isDisplayingLength);
    }

    function updateSnapButtons() {
        edo12SnapBtn.classList.toggle('toggled', activeEdoSnap === 12);
        edo24SnapBtn.classList.toggle('toggled', activeEdoSnap === 24);
        const customEdoVal = Math.max(2, parseInt(edoCustomInput.value, 10));
        edoCustomSnapBtn.classList.toggle('toggled', activeEdoSnap === customEdoVal);
        scaleSnapBtn.textContent = isScaleSnapOn ? "Scale Snap: On" : "Scale Snap: Off";
        scaleSnapBtn.classList.toggle('toggled', isScaleSnapOn);
        beatSnapBtn.textContent = isBeatSnapOn ? "Beat Snap: On" : "Beat Snap: Off";
        beatSnapBtn.classList.toggle('toggled', isBeatSnapOn);
    }
    
    function addCircle(pos) {
        let relativeX = pos.x / (PIXELS_PER_BEAT * horizontalZoom);
        
        const maxBeat = START_BEAT + parseInt(totalBeatsInput.value, 10);
        if (relativeX < START_BEAT || relativeX > maxBeat) return;

        circleCounter++;
        if (isBeatSnapOn) {
            relativeX = Math.round(relativeX * BEAT_SNAP_SUBDIVISION) / BEAT_SNAP_SUBDIVISION;
        }
        
        const initialLengthInBeats = parseFloat(initialNoteLengthSelect.value);
        const playLength = (initialLengthInBeats * 60) / tempo;

        circles.push({
            id: circleCounter, relativeX: relativeX,
            frequency: yToFrequency(pos.y), playLength: playLength, velocity: 100,
            playedThisCycle: false, colliding: false
        });
        draw();
    }
    
    function addChord(pos) {
        let relativeX = pos.x / (PIXELS_PER_BEAT * horizontalZoom);

        const maxBeat = START_BEAT + parseInt(totalBeatsInput.value, 10);
        if (relativeX < START_BEAT || relativeX > maxBeat) return;

        const chordType = chordTypeSelect.value;
        const arpBeats = parseFloat(arpBeatsInput.value);
        const numNotes = chordType === 'Triad' ? 3 : 4;
        
        const rootFreq = yToFrequency(pos.y);
        
        if (isBeatSnapOn) {
            relativeX = Math.round(relativeX * BEAT_SNAP_SUBDIVISION) / BEAT_SNAP_SUBDIVISION;
        }

        const scale = scaleIntervals[activeScale];
        const rootMidi = noteNameToMidi(activeRootNote);
        const clickedMidi = frequencyToMidiNote(rootFreq);

        if (rootMidi === null) { alert("Invalid root note for scale snap."); return; }

        const scaleMidiNotes = scale.map(interval => rootMidi + interval);
        let closestDist = Infinity;
        let rootDegreeIndex = 0;
        
        for(let i=0; i < scale.length; i++) {
            const dist = Math.abs(clickedMidi - (scaleMidiNotes[i] % 12));
            if(dist < closestDist) {
                closestDist = dist;
                rootDegreeIndex = i;
            }
        }
        
        const initialLengthInBeats = parseFloat(initialNoteLengthSelect.value);
        const playLength = (initialLengthInBeats * 60) / tempo;
        
        for (let i = 0; i < numNotes; i++) {
            const arpOffset = i * arpBeats;
            const notePosition = relativeX + arpOffset;

            if (notePosition > maxBeat) continue;

            circleCounter++;
            
            const scaleDegree = (rootDegreeIndex + (i * 2)) % scale.length;
            const octaveOffset = Math.floor((rootDegreeIndex + (i * 2)) / scale.length);
            
            const noteMidi = clickedMidi + (scale[scaleDegree] - scale[rootDegreeIndex]) + (octaveOffset * 12);
            const noteFreq = midiNoteToFrequency(noteMidi);
            
            circles.push({
                id: circleCounter,
                relativeX: notePosition,
                frequency: noteFreq,
                playLength: playLength,
                velocity: 100,
                playedThisCycle: false,
                colliding: false
            });
        }
        draw();
    }

    function deleteCircle(circleToDelete) {
        selectedCircles = selectedCircles.filter(c => c.id !== circleToDelete.id);
        circles = circles.filter(c => c.id !== circleToDelete.id);
        updateAdjustmentPanelVisibility();
        draw();
    }

    function openModal(circle) {
        if (selectedCircles.length !== 1) {
            selectedCircles = [circle];
        }
        modal.style.display = 'block';
        document.getElementById('modal-note-number').textContent = circle.id;
        document.getElementById('modal-horizontal-pos').value = (circle.relativeX - START_BEAT).toFixed(2);
        document.getElementById('modal-frequency').value = circle.frequency.toFixed(4);
        modalPlayLengthInput.value = circle.playLength.toFixed(2);
        document.getElementById('modal-velocity').value = circle.velocity;
        document.getElementById('modal-base-note').value = '';
        document.getElementById('modal-relative-interval').value = '';
        
        updateModalSelectFromPlayLength();
    }
    
    function updatePlayLengthFromModalSelect() {
        const selectedValue = modalNoteLengthSelect.value;
        if (selectedValue !== "custom") {
            const lengthInBeats = parseFloat(selectedValue);
            const newPlayLength = (lengthInBeats * 60) / tempo;
            modalPlayLengthInput.value = newPlayLength.toFixed(2);
        }
    }

    function updateModalSelectFromPlayLength() {
        const playLength = parseFloat(modalPlayLengthInput.value);
        if(isNaN(playLength)) return;
        
        const lengthInBeats = (playLength * tempo) / 60;
        
        let closestOption = 'custom';
        let minDiff = Infinity;
        
        for (const option of modalNoteLengthSelect.options) {
            if (option.value !== 'custom') {
                const diff = Math.abs(lengthInBeats - parseFloat(option.value));
                if (diff < 0.01 && diff < minDiff) {
                    minDiff = diff;
                    closestOption = option.value;
                }
            }
        }
        modalNoteLengthSelect.value = closestOption;
    }


    function applyModalChanges() {
        if (selectedCircles.length !== 1) return;
        const selectedCircle = selectedCircles[0];

        const hPosInput = document.getElementById('modal-horizontal-pos');
        const velocityInput = document.getElementById('modal-velocity');
        const manualFreqInput = document.getElementById('modal-frequency');
        const baseNoteIdInput = document.getElementById('modal-base-note').value;
        const relIntervalInput = document.getElementById('modal-relative-interval').value;

        let displayHPos = parseFloat(hPosInput.value);
        if (isNaN(displayHPos) || displayHPos < 0) { alert("Invalid Horizontal Position (must be 0 or greater)."); return; }
        
        let newHPos = displayHPos + START_BEAT;
        
        if (isBeatSnapOn) newHPos = Math.round(newHPos * BEAT_SNAP_SUBDIVISION) / BEAT_SNAP_SUBDIVISION;
        
        const maxBeat = START_BEAT + parseInt(totalBeatsInput.value, 10);
        if (newHPos > maxBeat) {
            alert(`Position cannot be greater than the total beats (${totalBeatsInput.value}).`);
            return;
        }
        selectedCircle.relativeX = newHPos;
        
        const newPlayLength = parseFloat(modalPlayLengthInput.value);
        if (isNaN(newPlayLength) || newPlayLength <= 0) { alert("Invalid Play Length."); return; }
        selectedCircle.playLength = newPlayLength;
        
        const newVelocity = parseInt(velocityInput.value, 10);
        if(isNaN(newVelocity) || newVelocity < 0 || newVelocity > 127) { alert("Velocity must be between 0 and 127."); return; }
        selectedCircle.velocity = newVelocity;
        
        if (manualFreqInput.value && relIntervalInput) { alert("Use either frequency OR interval, not both."); return; }
        
        let targetFreq;
        if (manualFreqInput.value) {
             targetFreq = parseFloat(manualFreqInput.value);
             if (isNaN(targetFreq) || targetFreq <= 0) { alert("Invalid frequency value."); return; }
        } else if (relIntervalInput) {
             let baseFreq;
             if (baseNoteIdInput) {
                const baseNote = circles.find(c => c.id === parseInt(baseNoteIdInput, 10));
                if (!baseNote) { alert(`Note ${baseNoteIdInput} not found.`); return; }
                baseFreq = baseNote.frequency;
             } else {
                baseFreq = centerLineFrequency;
             }
             try {
                const intervalRatio = new Function('return ' + relIntervalInput.replace(/\^/g, '**'))();
                targetFreq = baseFreq * intervalRatio;
             } catch (e) { alert("Invalid interval format."); return; }
        }

        if (targetFreq !== undefined) {
             if (activeEdoSnap > 0) {
                 const steps = activeEdoSnap * Math.log2(targetFreq / 440.0);
                 const roundedSteps = Math.round(steps);
                 targetFreq = 440 * Math.pow(2, roundedSteps / activeEdoSnap);
             }
             selectedCircle.frequency = targetFreq;
        }
        
        modal.style.display = 'none';
        draw();
    }

    function applyBulkAdjustment() {
        const hMove = parseFloat(document.getElementById('bulkHMove').value);
        const vMove = parseInt(document.getElementById('bulkVMove').value, 10);

        if (isNaN(hMove) || isNaN(vMove)) {
            alert("Invalid input for adjustment.");
            return;
        }

        const maxBeat = START_BEAT + parseInt(totalBeatsInput.value, 10);

        selectedCircles.forEach(circle => {
            // Horizontal adjustment
            let newHPos = circle.relativeX + hMove;
            newHPos = Math.max(START_BEAT, Math.min(maxBeat, newHPos));
            circle.relativeX = newHPos;

            // Vertical adjustment
            if (vMove !== 0) {
                const currentMidi = frequencyToMidiNote(circle.frequency);
                const newMidi = currentMidi + vMove;
                circle.frequency = midiNoteToFrequency(newMidi);
            }
        });

        // Reset inputs
        document.getElementById('bulkHMove').value = 0;
        document.getElementById('bulkVMove').value = 0;

        draw();
    }
    
    function makeModalDraggable(element, header) {
        let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
        header.onmousedown = dragMouseDown;
        function dragMouseDown(e) {
            e = e || window.event; e.preventDefault();
            pos3 = e.clientX; pos4 = e.clientY;
            document.onmouseup = closeDragElement;
            document.onmousemove = elementDrag;
        }
        function elementDrag(e) {
            e = e || window.event; e.preventDefault();
            pos1 = pos3 - e.clientX; pos2 = pos4 - e.clientY;
            pos3 = e.clientX; pos4 = e.clientY;
            element.style.top = (element.offsetTop - pos2) + "px";
            element.style.left = (element.offsetLeft - pos1) + "px";
        }
        function closeDragElement() { document.onmouseup = null; document.onmousemove = null; }
    }
    
    // --- Theme Functions ---
    function applyTheme(themeName) {
        currentTheme = THEMES[themeName];
        const root = document.documentElement;
        Object.keys(currentTheme).forEach(key => {
            const cssVarName = `--${key.replace(/([A-Z])/g, '-$1').toLowerCase()}`;
            root.style.setProperty(cssVarName, currentTheme[key]);
        });
        recolorImages();
        draw();
    }
    
    function colorizeImage(sourceImage, color) {
        if (!sourceImage.complete || sourceImage.naturalWidth === 0) return null;
        const offscreenCanvas = document.createElement('canvas');
        offscreenCanvas.width = sourceImage.naturalWidth;
        offscreenCanvas.height = sourceImage.naturalHeight;
        const offscreenCtx = offscreenCanvas.getContext('2d');
        
        offscreenCtx.fillStyle = color;
        offscreenCtx.fillRect(0, 0, offscreenCanvas.width, offscreenCanvas.height);
        offscreenCtx.globalCompositeOperation = 'destination-in';
        offscreenCtx.drawImage(sourceImage, 0, 0);
        
        return offscreenCanvas;
    }
    
    function recolorImages() {
        for (const key in sourceImages) {
            coloredImages[key] = colorizeImage(sourceImages[key], currentTheme.notes);
            coloredPlayheadImages[key] = colorizeImage(sourceImages[key], currentTheme.playhead);
        }
        draw();
    }
    
    function toggleReverb() {
        const isConnected = reverbBtn.classList.toggle('toggled');
        if(isConnected) {
            wetGain.connect(convolver);
            convolver.connect(masterGain);
            reverbBtn.textContent = "Reverb: On";
        } else {
            wetGain.disconnect();
            convolver.disconnect();
            reverbBtn.textContent = "Reverb: Off";
        }
    }
    
    function toggleDelay() {
        const isConnected = delayBtn.classList.toggle('toggled');
        if(isConnected) {
            delayWetGain.gain.value = delayMixSlider.value;
            delayDryGain.gain.value = 1.0 - delayMixSlider.value;
            delayBtn.textContent = "Delay: On";
        } else {
            delayWetGain.gain.value = 0;
            delayDryGain.gain.value = 1.0;
            delayBtn.textContent = "Delay: Off";
        }
    }
    
    function createReverbIR() {
        const sampleRate = audioContext.sampleRate;
        const length = sampleRate * 2;
        const impulse = audioContext.createBuffer(2, length, sampleRate);
        const impulseL = impulse.getChannelData(0);
        const impulseR = impulse.getChannelData(1);
        for (let i = 0; i < length; i++) {
            impulseL[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, 2.5);
            impulseR[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, 2.5);
        }
        return impulse;
    }

    // --- Utility Functions ---
    function getEventPos(evt) {
        const rect = canvas.getBoundingClientRect();
        const event = evt.touches ? evt.touches[0] : evt;
        return { x: event.clientX - rect.left, y: event.clientY - rect.top };
    }

    function getCircleAtPos(pos) {
        // Search backwards so we get the top-most circle first
        for (let i = circles.length - 1; i >= 0; i--) {
            const circle = circles[i];
            const x = circle.relativeX * PIXELS_PER_BEAT * horizontalZoom;
            const y = frequencyToY(circle.frequency);
            const distance = Math.sqrt((pos.x - x) ** 2 + (pos.y - y) ** 2);
            if (distance < circleRadius + 4) return circle;
        }
        return null;
    }
    
    function getLassoRect() {
        const x = Math.min(lassoStartPos.x, lassoEndPos.x);
        const y = Math.min(lassoStartPos.y, lassoEndPos.y);
        const w = Math.abs(lassoStartPos.x - lassoEndPos.x);
        const h = Math.abs(lassoStartPos.y - lassoEndPos.y);
        return { x, y, w, h };
    }

    function selectCirclesInLasso() {
        const rect = getLassoRect();
        const newlySelected = [];
        circles.forEach(circle => {
            const x = circle.relativeX * PIXELS_PER_BEAT * horizontalZoom;
            const y = frequencyToY(circle.frequency);
            if (x >= rect.x && x <= rect.x + rect.w && y >= rect.y && y <= rect.y + rect.h) {
                newlySelected.push(circle);
            }
        });
        selectedCircles.push(...newlySelected.filter(c => !selectedCircles.includes(c)));
    }
    
    function cycleNoteLength(note) {
        const currentLengthInBeats = (note.playLength * tempo) / 60;
        let currentIndex = -1;
        for(let i = 0; i < NOTE_DURATIONS_IN_BEATS.length; i++){
            if(Math.abs(currentLengthInBeats - NOTE_DURATIONS_IN_BEATS[i]) < 0.01){
                currentIndex = i;
                break;
            }
        }
        const nextIndex = (currentIndex + 1) % NOTE_DURATIONS_IN_BEATS.length;
        const newLengthInBeats = NOTE_DURATIONS_IN_BEATS[nextIndex];
        note.playLength = (newLengthInBeats * 60) / tempo;
    }

    function getNoteValueImage(playLength, tempo) {
        const lengthInBeats = (playLength * tempo) / 60;
        if (lengthInBeats > 3) return sourceImages.whole;
        if (lengthInBeats > 1.5) return sourceImages.half;
        if (lengthInBeats > 0.75) return sourceImages.quarter;
        if (lengthInBeats > 0.375) return sourceImages.eighth;
        return sourceImages.sixteenth;
    }

    function frequencyToNoteAndCents(freq) {
        const A4 = 440.0;
        const midiNum = 69 + 12 * Math.log2(freq / A4);
        const roundedMidiNum = Math.round(midiNum);
        const noteIndex = roundedMidiNum % 12;
        const octave = Math.floor(roundedMidiNum / 12) - 1;
        const name = noteNames[noteIndex] + octave;
        const perfectFreq = A4 * Math.pow(2, (roundedMidiNum - 69) / 12);
        const cents = 1200 * Math.log2(freq / perfectFreq);
        return { name, cents };
    }
    
    function getCentsFromNatural(freq) {
        const midiNum = 69 + 12 * Math.log2(freq / 440.0);
        let naturalMidiNum = Math.floor(midiNum);
        while (noteNames[naturalMidiNum % 12].includes('#')) {
            naturalMidiNum--;
        }
        const naturalFreq = 440 * Math.pow(2, (naturalMidiNum - 69) / 12);
        const cents = 1200 * Math.log2(freq / naturalFreq);
        return cents;
    }
    
    function noteNameToMidi(name) {
        const noteNameMap = { C: 0, D: 2, E: 4, F: 5, G: 7, A: 9, B: 11 };
        const match = name.trim().match(/^([A-G])([#b]?)(\d+)$/i);
        if (!match) return null;

        let note = noteNameMap[match[1].toUpperCase()];
        if (match[2] === '#') note++;
        if (match[2] === 'b') note--;
        
        const octave = parseInt(match[3], 10);
        return note + (octave + 1) * 12;
    }
    
    function convertStepsToIntervals(steps) {
        const intervals = [0];
        let currentStep = 0;
        for (let i = 0; i < steps.length - 1; i++) {
            currentStep += steps[i];
            intervals.push(currentStep);
        }
        return intervals;
    }

    function midiNoteToFrequency(note) { return 440 * Math.pow(2, (note - 69) / 12); }
    
    function frequencyToMidiNote(freq) { return Math.round(69 + 12 * Math.log2(freq / 440)); }

    // --- Let's Go! ---
    window.addEventListener('load', (event) => {
        init();
    });
</script>

<script src="midi_functions.js" defer></script>
</body>
</html>
